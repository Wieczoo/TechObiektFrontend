{"version":3,"sources":["../../../../src/core/utils/request/onUnhandledRequest.ts"],"sourcesContent":["import jsLevenshtein from '@bundled-es-modules/js-levenshtein'\nimport { RequestHandler, HttpHandler, GraphQLHandler } from '../..'\nimport {\n  ParsedGraphQLQuery,\n  ParsedGraphQLRequest,\n  parseGraphQLRequest,\n} from '../internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from './getPublicUrlFromRequest'\nimport { isStringEqual } from '../internal/isStringEqual'\nimport { devUtils } from '../internal/devUtils'\n\nconst getStringMatchScore = jsLevenshtein\n\nconst MAX_MATCH_SCORE = 3\nconst MAX_SUGGESTION_COUNT = 4\nconst TYPE_MATCH_DELTA = 0.5\n\nexport interface UnhandledRequestPrint {\n  warning(): void\n  error(): void\n}\n\nexport type UnhandledRequestCallback = (\n  request: Request,\n  print: UnhandledRequestPrint,\n) => void\n\nexport type UnhandledRequestStrategy =\n  | 'bypass'\n  | 'warn'\n  | 'error'\n  | UnhandledRequestCallback\n\ninterface RequestHandlerGroups {\n  http: Array<HttpHandler>\n  graphql: Array<GraphQLHandler>\n}\n\nfunction groupHandlersByType(\n  handlers: Array<RequestHandler>,\n): RequestHandlerGroups {\n  return handlers.reduce<RequestHandlerGroups>(\n    (groups, handler) => {\n      if (handler instanceof HttpHandler) {\n        groups.http.push(handler)\n      }\n\n      if (handler instanceof GraphQLHandler) {\n        groups.graphql.push(handler)\n      }\n\n      return groups\n    },\n    {\n      http: [],\n      graphql: [],\n    },\n  )\n}\n\ntype RequestHandlerSuggestion = [number, RequestHandler]\n\ntype ScoreGetterFn<RequestHandlerType extends RequestHandler> = (\n  request: Request,\n  handler: RequestHandlerType,\n) => number\n\nfunction getHttpHandlerScore(): ScoreGetterFn<HttpHandler> {\n  return (request, handler) => {\n    const { path, method } = handler.info\n\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity\n    }\n\n    const hasSameMethod = isStringEqual(request.method, method)\n\n    // Always treat a handler with the same method as a more similar one.\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n    const score = getStringMatchScore(requestPublicUrl, path)\n\n    return score - methodScoreDelta\n  }\n}\n\nfunction getGraphQLHandlerScore(\n  parsedQuery: ParsedGraphQLQuery,\n): ScoreGetterFn<GraphQLHandler> {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === 'undefined') {\n      return Infinity\n    }\n\n    const { operationType, operationName } = handler.info\n\n    if (typeof operationName !== 'string') {\n      return Infinity\n    }\n\n    const hasSameOperationType = parsedQuery.operationType === operationType\n    // Always treat a handler with the same operation type as a more similar one.\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0\n    const score = getStringMatchScore(parsedQuery.operationName, operationName)\n\n    return score - operationTypeScoreDelta\n  }\n}\n\nfunction getSuggestedHandler(\n  request: Request,\n  handlers: Array<HttpHandler> | Array<GraphQLHandler>,\n  getScore: ScoreGetterFn<HttpHandler> | ScoreGetterFn<GraphQLHandler>,\n): Array<RequestHandler> {\n  const suggestedHandlers = (handlers as Array<RequestHandler>)\n    .reduce<Array<RequestHandlerSuggestion>>((suggestions, handler) => {\n      const score = getScore(request, handler as any)\n      return suggestions.concat([[score, handler]])\n    }, [])\n    .sort(([leftScore], [rightScore]) => leftScore - rightScore)\n    .filter(([score]) => score <= MAX_MATCH_SCORE)\n    .slice(0, MAX_SUGGESTION_COUNT)\n    .map(([, handler]) => handler)\n\n  return suggestedHandlers\n}\n\nfunction getSuggestedHandlersMessage(handlers: RequestHandler[]) {\n  if (handlers.length > 1) {\n    return `\\\nDid you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `  â€¢ ${handler.info.header}`).join('\\n')}`\n  }\n\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`\n}\n\nexport async function onUnhandledRequest(\n  request: Request,\n  handlers: Array<RequestHandler>,\n  strategy: UnhandledRequestStrategy = 'warn',\n): Promise<void> {\n  const parsedGraphQLQuery = await parseGraphQLRequest(request).catch(\n    () => null,\n  )\n  const publicUrl = getPublicUrlFromRequest(request)\n\n  function generateHandlerSuggestion(): string {\n    /**\n     * @note Ignore exceptions during GraphQL request parsing because at this point\n     * we cannot assume the unhandled request is a valid GraphQL request.\n     * If the GraphQL parsing fails, just don't treat it as a GraphQL request.\n     */\n    const handlerGroups = groupHandlersByType(handlers)\n    const relevantHandlers = parsedGraphQLQuery\n      ? handlerGroups.graphql\n      : handlerGroups.http\n\n    const suggestedHandlers = getSuggestedHandler(\n      request,\n      relevantHandlers,\n      parsedGraphQLQuery\n        ? getGraphQLHandlerScore(parsedGraphQLQuery)\n        : getHttpHandlerScore(),\n    )\n\n    return suggestedHandlers.length > 0\n      ? getSuggestedHandlersMessage(suggestedHandlers)\n      : ''\n  }\n\n  function getGraphQLRequestHeader(\n    parsedGraphQLRequest: ParsedGraphQLRequest<any>,\n  ): string {\n    if (!parsedGraphQLRequest?.operationName) {\n      return `anonymous ${parsedGraphQLRequest?.operationType} (${request.method} ${publicUrl})`\n    }\n\n    return `${parsedGraphQLRequest.operationType} ${parsedGraphQLRequest.operationName} (${request.method} ${publicUrl})`\n  }\n\n  function generateUnhandledRequestMessage(): string {\n    const requestHeader = parsedGraphQLQuery\n      ? getGraphQLRequestHeader(parsedGraphQLQuery)\n      : `${request.method} ${publicUrl}`\n    const handlerSuggestion = generateHandlerSuggestion()\n\n    const messageTemplate = [\n      `intercepted a request without a matching request handler:`,\n      `  \\u2022 ${requestHeader}`,\n      handlerSuggestion,\n      `\\\nIf you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks\\\n`,\n    ].filter(Boolean)\n    return messageTemplate.join('\\n\\n')\n  }\n\n  function applyStrategy(strategy: UnhandledRequestStrategy) {\n    // Generate handler suggestions only when applying the strategy.\n    // This saves bandwidth for scenarios when developers opt-out\n    // from the default unhandled request handling strategy.\n    const message = generateUnhandledRequestMessage()\n\n    switch (strategy) {\n      case 'error': {\n        // Print a developer-friendly error.\n        devUtils.error('Error: %s', message)\n\n        // Throw an exception to halt request processing and not perform the original request.\n        throw new Error(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.',\n          ),\n        )\n      }\n\n      case 'warn': {\n        devUtils.warn('Warning: %s', message)\n        break\n      }\n\n      case 'bypass':\n        break\n\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy,\n          ),\n        )\n    }\n  }\n\n  if (typeof strategy === 'function') {\n    strategy(request, {\n      warning: applyStrategy.bind(null, 'warn'),\n      error: applyStrategy.bind(null, 'error'),\n    })\n    return\n  }\n\n  applyStrategy(strategy)\n}\n"],"mappings":"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","names":["jsLevenshtein","strategy"]}